\documentclass[thesis.tex]{subfiles}

\begin{document}

\chapter{Conclusion and Future Directions}
\label{cha:concl-future-work}

This thesis claims that systematic adaptation and quantitative profiling are the
key to a resilient swarm. This chapter summarizes our work, discusses future
directions, and concludes this thesis.

\section{Thesis Summary}
\label{sec:thesis-summary-1}

This thesis began with an overview of the emerging swarm. As the swarm grows at
a staggering rate, it faces challenges from the underlying communication and
computation infrastructure: the scarce and variable WAN bandwidth and the
heterogeneous compute environment. Existing approaches with manual policies or
application-specific policies do not work for the swarm scale.

I propose to adapt swarm applications in a systematic and quantitative way. The
proposed methodology consists of three parts: $(i)$ a set of well-defined
programming abstractions that allow developers to express what adaptation
options are available; $(ii)$ a data-driven profiling tool that automatically
learns a Pareto-optimal profile; $(iii)$ runtime adaptation that maximizes
application performance while satisfying resource constrains. We apply our
methodology to network resources and compute resources.

For network resources, swarm applications need to address the scarce and
variable WAN bandwidth by exploring the trade-off between application accuracy
and data size demand. In \autoref{cha:netw-reso-adapt}, we have presented our
design, implementation, and evaluation of \awstream{}. Compared with
non-adaptive applications, \awstream{} achieves a 40--100$\times$ reduction in
latency relative to applications using TCP, and a 45--88\% improvement in
application accuracy relative to applications using UDP. Compared with manual
policies using a state-of-the-art system JetStream~\cite{rabkin2014aggregation},
\awstream{} achieves a 15-20$\times$ reduction in latency and 1-5\% improvement
in accuracy simultaneously.

For compute resources, swarm applications need to address the heterogeneous
compute environment by exploring the trade-off between application accuracy and
processing times. In \autoref{cha:comp-reso-adapt}, we have focused on improving
profiling efficiency. First, we use Bayesian Optimization to avoid an exhaustive
exploration of the large parameter space. BO significantly reduces the number of
samples needed, by more than 50$\times$. With the same search budget, BO finds
better Pareto-optimal configurations than previous proposed search
methods. Second, to profile for new devices, we propose to transfer an existing
profile by updating the processing times of Pareto-optimal configurations. The
profile transfer eliminates the need for getting all training data, evaluating
the algorithm for all data, and running a BO engine.

In summary, this thesis presents a systematic and quantitative approach for
adaptation.

\section{Future Directions}
\label{sec:future-directions}

Before concluding this thesis, I discuss three directions that I find valuable
as future work. Earlier in \autoref{sec:awstream-discussion} and
\autoref{sec:brt-discussion}, we have discussed potential improvements that are
near term and specific to our current design and implementation. This section
focuses on future directions that are in a longer term and for a broader
context.

\para{More Diverse Applications and Generalization.} The core challenge for the
swarm comes from the scale of interconnected devices. As the number of devices
continues to grow, we expect to see more diverse swarm applications. While we
have used several applications in this thesis as case studies, we need more
applications to evaluate how general the proposed APIs are, how effective the
profiling techniques are, and how responsive the runtime system is. Some
enhancements may be easy to incorporate into our existing system. For example,
because our APIs are extensible, we can build a library of reusable functions
for adaptation options and accuracy measurements to reduce developer
efforts. Other enhancements may require a redesign of APIs, profiling tools,
and/or the runtime.

\para{Adaptation and Resource Allocation.} In addition to adapting to resources,
swarm applications should be able to dynamically \emph{recruit} resources, such
as sensors, actuators, data, and computing infrastructure. We have envisioned
SwarmOS that controls and allocates resources for different swarm
applications. However, some swarm resources are beyond the control of individual
entities (such as WAN bandwidth that is); some swarm resources are not as
elastic as the cloud (such as end devices that need to be purchased and
installed). In these cases, swarm applications need to adapt to such
resources. One interesting direction is to use a combination of adaptation and
resource allocation. In \autoref{sec:resource-allocation}, we explored
allocating available bandwidth among multiple applications and how different
allocation schemes affect application behaviors. We believe this is an important
future direction for the SwarmOS vision.

\para{Adaptation and Mutation.} The adaptation we have explored thus far is
limited in what can be changed: applications only change the algorithms and
parameters that a developer has specified as adaptation options. An extreme case
for adaptation is self-modifying code, which is notoriously difficult to
understand and manage. A slightly more flexible yet still disciplined approach
is mutable accessors as discussed by Brooks et al.~\cite{brooks2018component}. A
mutable accessor is an abstract interface specification for candidate
accessors. It reifies a concrete accessor downloaded from the Internet or
retrieved through a discovery mechanism. In summary, along the spectrum of
adaptation, we expect future work will extend our profiling methodology to
applications that change their structure and mutate their implementation.

\section{Reflections and Concluding Remarks}
\label{sec:conclusions}

We now discuss a few broad lessons learned over the course of this research.

The hype of the swarm.

The broader impact of adaptation.

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
